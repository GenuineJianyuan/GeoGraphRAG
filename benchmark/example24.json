{
    "query": "Analyze spatial autocorrelation of village development levels",
    "datasource": [
        "Village boundary vector data"
    ],
    "raw_code": "var villages = ee.FeatureCollection('users/your_user/Nanyang');\n\nvar villagesWithCentroids = villages.map(function(feature) {\n  var centroid = feature.geometry().centroid();\n  return feature.set('centroid', centroid);\n});\n\nvar thresholdDistance = 10000;\nvar distanceMatrix = villagesWithCentroids.map(function(featureA) {\n  return villagesWithCentroids.map(function(featureB) {\n    var dist = featureA.geometry().distance(featureB.geometry());\n    return ee.Feature(null, {'dist': dist, 'pair': [featureA.id(), featureB.id()]});\n  });\n}).flatten();\n\nvar weightMatrix = distanceMatrix.filter(ee.Filter.lt('dist', thresholdDistance))\n                                 .map(function(f) { return f.set('weight', 1); });\n\nvar level = villagesWithCentroids.aggregate_array('level');\nvar zLevel = ee.Array(level).subtract(ee.Number(ee.Array(level).reduce('mean')))\n                           .divide(ee.Number(ee.Array(level).reduce('stdev')));\n\nvar localMoranI = zLevel.multiply(weightMatrix.aggregate_array('weight'));\nvar numSimulations = 999;\nvar simulatedMoran = ee.List.repeat(ee.List(zLevel), numSimulations);\n\nvar pValues = simulatedMoran.map(function(sim) {\n  return sim.map(function(simulated) {\n    return ee.Number(simulated).gte(localMoranI);\n  });\n});\n\nvar classified = villagesWithCentroids.map(function(feature) {\n  var weightedSum = ee.Array(weightMatrix.aggregate_array('weight')).dot(zLevel);\n  var region = ee.Algorithms.If(\n    zLevel.get(feature.id()).gt(0).and(weightedSum.gt(0)),\n    'High-High',\n    ee.Algorithms.If(\n      zLevel.get(feature.id()).gt(0).and(weightedSum.lt(0)),\n      'High-Low',\n      ee.Algorithms.If(\n        zLevel.get(feature.id()).lt(0).and(weightedSum.gt(0)),\n        'Low-High',\n        'Low-Low'\n      )\n    )\n  );\n  return feature.set('region', region);\n});\n\nvar visualization = classified.map(function(feature) {\n  var region = feature.get('region');\n  var color = ee.Algorithms.If(region, {'High-High':'red','High-Low':'green','Low-High':'blue','Low-Low':'yellow'}[region], 'gray');\n  return feature.set('color', color);\n});\n\nMap.addLayer(visualization, {color: 'color'}, 'Classification Results');\nMap.centerObject(villagesWithCentroids, 10);",
    "api": [
        "ee.FeatureCollection",
        "ee.FeatureCollection.map",
        "ee.Geometry.centroid",
        "ee.Feature.set",
        "ee.Number",
        "ee.Filter.lt",
        "ee.Array.subtract",
        "ee.Array.reduce",
        "ee.Array.divide",
        "ee.Array.multiply",
        "ee.List.repeat",
        "ee.List.map",
        "ee.Algorithms.If",
        "ee.Array.dot",
        "ee.Image.style",
        "Map.addLayer",
        "Map.centerObject"
    ],
    "processing step": [
        "Load village feature collection",
        "Calculate centroids for villages",
        "Compute pairwise distance matrix",
        "Filter distances below threshold",
        "Standardize village level values",
        "Calculate local Moran's I",
        "Simulate Moran's I for p-values",
        "Classify regions based on Moran's I",
        "Visualize classification results"
    ],
    "output": "Map showing spatial autocorrelation classification."
}